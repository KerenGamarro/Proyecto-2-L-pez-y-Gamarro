#include <Arduino.h>
#include "driver/spi_slave.h"
#include "driver/gpio.h"

// Pines SPI (VSPI)
static const int PIN_MOSI = 23;
static const int PIN_MISO = 19;
static const int PIN_SCLK = 18;
static const int PIN_SS   = 5;

// LEDs
#define LED1 25
#define LED2 4
#define LED3 2

static void ejecutar_led(uint8_t led_num, uint16_t tiempo_ms) {
  int pin = 0;
  switch (led_num) {
    case 1: pin = LED1; Serial.print("LED1 "); break;
    case 2: pin = LED2; Serial.print("LED2 "); break;
    case 3: pin = LED3; Serial.print("LED3 "); break;
    default: return;
  }
  if (tiempo_ms < 1) tiempo_ms = 1;
  if (tiempo_ms > 5000) tiempo_ms = 5000;

  Serial.print("ON "); Serial.print(tiempo_ms); Serial.println(" ms");
  digitalWrite(pin, HIGH);
  delay(tiempo_ms);
  digitalWrite(pin, LOW);
  Serial.println("OFF");
}

void setup() {
  Serial.begin(115200);
  delay(300);

  pinMode(LED1, OUTPUT);
  pinMode(LED2, OUTPUT);
  pinMode(LED3, OUTPUT);
  digitalWrite(LED1, LOW);
  digitalWrite(LED2, LOW);
  digitalWrite(LED3, LOW);

  // Configuración del bus VSPI para esclavo
  spi_bus_config_t buscfg = {};
  buscfg.mosi_io_num = PIN_MOSI;
  buscfg.miso_io_num = PIN_MISO;
  buscfg.sclk_io_num = PIN_SCLK;
  buscfg.quadwp_io_num = -1;
  buscfg.quadhd_io_num = -1;
  buscfg.max_transfer_sz = 3; // 3 bytes exactos

  // Configuración del esclavo
  spi_slave_interface_config_t slvcfg = {};
  slvcfg.mode = 0;                        // MODE0 (CPOL=0, CPHA=0)
  slvcfg.spics_io_num = PIN_SS;           // NSS/CS en GPIO5
  slvcfg.queue_size = 3;                  // cola de transacciones
  slvcfg.flags = 0;
  slvcfg.post_setup_cb = NULL;
  slvcfg.post_trans_cb = NULL;

  // Pull-ups para estabilidad en línea SS (opcional pero ayuda)
  gpio_set_pull_mode((gpio_num_t)PIN_SS, GPIO_PULLUP_ONLY);

  // Inicializar bus y esclavo
  esp_err_t e;
  e = spi_slave_initialize(VSPI_HOST, &buscfg, &slvcfg, SPI_DMA_DISABLED);
  if (e != ESP_OK) { Serial.println("spi_slave_initialize ERROR"); while(true){} }

  Serial.println("\n[READY] ESP32 SPI Slave (ESP-IDF) — esperando 3 bytes...");
}

void loop() {
  uint8_t rx[3] = {0};
  uint8_t tx_dummy[3] = {0};
  spi_slave_transaction_t t = {};

  t.length = 3 * 8;         // bits a recibir
  t.rx_buffer = rx;
  t.tx_buffer = tx_dummy;   // no enviamos nada relevante

  // Espera una transacción del master
  esp_err_t err = spi_slave_transmit(VSPI_HOST, &t, portMAX_DELAY);
  if (err == ESP_OK) {
    uint8_t led = rx[0];
    uint16_t tiempo = ((uint16_t)rx[1] << 8) | rx[2];

    Serial.print("[SPI] Recibido -> LED="); Serial.print(led);
    Serial.print(" tiempo="); Serial.print(tiempo); Serial.println(" ms");

    if (led >= 1 && led <= 3) {
      ejecutar_led(led, tiempo);
    } else {
      Serial.println("ERROR: LED invalido (use 1..3)");
    }
  } else {
    Serial.print("spi_slave_transmit ERROR: "); Serial.println((int)err);
    delay(10);
  }
}
